<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Incremental Data Processing in JavaScript: A Technical Overview</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Serif:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #1c2128;
      --text-primary: #c9d1d9;
      --text-secondary: #8b949e;
      --text-muted: #6e7681;
      --accent: #58a6ff;
      --green: #3fb950;
      --orange: #d29922;
      --red: #f85149;
      --purple: #a371f7;
      --border: #30363d;
      --code-bg: #0d1117;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }

    body {
      font-family: 'IBM Plex Sans', -apple-system, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.7;
      font-size: 16px;
    }

    header {
      padding: 80px 40px 60px;
      border-bottom: 1px solid var(--border);
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      font-family: 'IBM Plex Serif', Georgia, serif;
      font-size: 2rem;
      font-weight: 500;
      line-height: 1.3;
      margin-bottom: 16px;
      color: var(--text-primary);
    }

    .subtitle {
      font-size: 1rem;
      color: var(--text-secondary);
      margin-bottom: 24px;
    }

    .meta {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 13px;
      color: var(--text-muted);
    }

    nav {
      position: sticky;
      top: 0;
      background: rgba(13, 17, 23, 0.95);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid var(--border);
      z-index: 100;
    }

    .nav-inner {
      max-width: 800px;
      margin: 0 auto;
      display: flex;
      gap: 4px;
      padding: 12px 40px;
      overflow-x: auto;
    }

    nav a {
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 13px;
      font-family: 'IBM Plex Mono', monospace;
      padding: 6px 12px;
      border-radius: 4px;
      white-space: nowrap;
      transition: all 0.15s;
    }

    nav a:hover { color: var(--text-primary); background: var(--bg-tertiary); }
    nav a.active { color: var(--accent); background: rgba(88, 166, 255, 0.1); }

    main { max-width: 800px; margin: 0 auto; padding: 48px 40px; }
    section { margin-bottom: 64px; scroll-margin-top: 70px; }

    h2 {
      font-family: 'IBM Plex Serif', Georgia, serif;
      font-size: 1.5rem;
      font-weight: 500;
      margin-bottom: 20px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }

    h3 {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 32px 0 12px;
      color: var(--text-primary);
    }

    p { margin-bottom: 16px; color: var(--text-secondary); }
    strong { color: var(--text-primary); font-weight: 500; }

    ul, ol { margin: 16px 0; padding-left: 24px; color: var(--text-secondary); }
    li { margin-bottom: 8px; }

    .note {
      background: var(--bg-secondary);
      border-left: 3px solid var(--accent);
      padding: 16px 20px;
      margin: 24px 0;
      font-size: 15px;
    }

    .note p { margin-bottom: 0; color: var(--text-secondary); }

    pre {
      background: var(--code-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 16px;
      overflow-x: auto;
      margin: 20px 0;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 13px;
      line-height: 1.5;
    }

    code { font-family: 'IBM Plex Mono', monospace; }
    :not(pre) > code { background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px; font-size: 14px; }

    .code-comment { color: var(--text-muted); }
    .code-keyword { color: var(--purple); }
    .code-string { color: var(--green); }
    .code-number { color: var(--orange); }
    .code-function { color: var(--accent); }
    .code-type { color: #79c0ff; }

    .diagram {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 24px;
      margin: 24px 0;
      overflow-x: auto;
    }

    .diagram-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      margin-bottom: 16px;
    }

    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin: 24px 0;
    }

    @media (max-width: 700px) { .comparison { grid-template-columns: 1fr; } }

    .comparison-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 16px;
    }

    .comparison-item h4 {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-muted);
    }

    .memory-layout {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 12px;
    }

    .memory-row { display: flex; align-items: center; gap: 8px; }
    .memory-label { width: 70px; color: var(--text-muted); text-align: right; font-size: 11px; }
    .memory-cells { display: flex; gap: 2px; }

    .memory-cell {
      width: 52px; height: 28px;
      display: flex; align-items: center; justify-content: center;
      border-radius: 3px;
      font-size: 10px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }

    .memory-cell.sym { border-color: var(--purple); color: var(--purple); }
    .memory-cell.price { border-color: var(--green); color: var(--green); }
    .memory-cell.qty { border-color: var(--accent); color: var(--accent); }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      margin: 20px 0;
    }

    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border); }
    th { font-weight: 500; color: var(--text-muted); font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
    td { color: var(--text-secondary); }
    tr:hover td { background: var(--bg-secondary); }

    .weight {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px; height: 24px;
      border-radius: 50%;
      font-size: 12px;
      font-weight: 500;
      font-family: 'IBM Plex Mono', monospace;
    }

    .weight.pos { background: rgba(63, 185, 80, 0.15); color: var(--green); }
    .weight.neg { background: rgba(248, 81, 73, 0.15); color: var(--red); }

    .ticker { font-weight: 500; color: var(--text-primary); }

    .pipeline {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 16px 0;
      overflow-x: auto;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 12px;
    }

    .pipeline-node {
      padding: 10px 14px;
      border-radius: 4px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      white-space: nowrap;
    }

    .pipeline-node small { display: block; color: var(--text-muted); font-size: 10px; margin-top: 2px; }
    .pipeline-arrow { color: var(--text-muted); }

    .demo {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      overflow: hidden;
      margin: 24px 0;
    }

    .demo-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
      gap: 12px;
      flex-wrap: wrap;
    }

    .demo-title { font-family: 'IBM Plex Mono', monospace; font-size: 12px; color: var(--text-secondary); }
    .demo-controls { display: flex; gap: 6px; }

    .demo-btn {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      padding: 5px 10px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }

    .demo-btn:hover { border-color: var(--text-muted); color: var(--text-primary); }
    .demo-btn.buy { border-color: var(--green); color: var(--green); }
    .demo-btn.sell { border-color: var(--red); color: var(--red); }

    .demo-body { padding: 16px; }

    .state-display {
      display: flex;
      gap: 16px;
      margin-bottom: 12px;
      font-family: 'IBM Plex Mono', monospace;
    }

    .state-item {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 10px 16px;
    }

    .state-item .label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; }
    .state-item .value { font-size: 20px; color: var(--text-primary); }
    .state-item .value.negative { color: var(--red); }

    .log {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      max-height: 140px;
      overflow-y: auto;
      background: var(--bg-primary);
      border-radius: 4px;
      padding: 10px;
    }

    .log-entry { padding: 3px 0; border-bottom: 1px solid var(--border); color: var(--text-muted); }
    .log-entry:last-child { border-bottom: none; }
    .log-entry .action { color: var(--purple); }
    .log-entry .num { color: var(--orange); }
    .log-entry .result { color: var(--green); }
    .log-entry .result.neg { color: var(--red); }

    .perf-bars {
      display: flex;
      align-items: flex-end;
      gap: 24px;
      height: 120px;
      padding: 0 16px;
      margin-bottom: 8px;
    }

    .perf-bar-group { display: flex; flex-direction: column; align-items: center; gap: 6px; }

    .perf-bar {
      width: 48px;
      border-radius: 3px 3px 0 0;
      position: relative;
    }

    .perf-bar .val {
      position: absolute;
      top: -18px; left: 50%;
      transform: translateX(-50%);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .perf-bar.a { background: var(--red); }
    .perf-bar.b { background: var(--orange); }
    .perf-bar.c { background: var(--purple); }
    .perf-bar.d { background: var(--green); }

    .perf-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
    }

    .good { color: var(--green); }
    .warn { color: var(--orange); }

    footer {
      border-top: 1px solid var(--border);
      padding: 32px 40px;
      max-width: 800px;
      margin: 0 auto;
    }

    footer p { font-size: 13px; color: var(--text-muted); margin-bottom: 8px; }
    footer a { color: var(--accent); text-decoration: none; }
    footer a:hover { text-decoration: underline; }

    .reveal { opacity: 0; transform: translateY(20px); transition: opacity 0.5s, transform 0.5s; }
    .reveal.visible { opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <header>
    <h1>Incremental Data Processing in JavaScript</h1>
    <p class="subtitle">
      Combining columnar storage with delta-based computation for real-time trade analytics.
    </p>
    <p class="meta">Technical overview • Based on PandaJS architecture</p>
  </header>

  <nav>
    <div class="nav-inner">
      <a href="#overview" class="active">Overview</a>
      <a href="#columnar">Columnar Storage</a>
      <a href="#zsets">Z-Sets</a>
      <a href="#operators">Operators</a>
      <a href="#accumulators">Accumulators</a>
      <a href="#benchmarks">Benchmarks</a>
    </div>
  </nav>

  <main>
    <section id="overview" class="reveal">
      <h2>Overview</h2>
      
      <p>
        Traditional DataFrame implementations recompute aggregations from scratch on each update. 
        For a trading system processing millions of trades, this means recalculating VWAP, positions, 
        and P&L across the entire dataset whenever a single trade arrives.
      </p>

      <p>
        Incremental processing avoids this by maintaining intermediate state and applying updates 
        only to the changed data. Combined with columnar storage (TypedArrays), this approach 
        achieves significant performance improvements.
      </p>

      <div class="comparison">
        <div class="comparison-item">
          <h4>Full recomputation</h4>
          <pre><code><span class="code-comment">// O(n) on every update</span>
trades.<span class="code-function">push</span>(newTrade);
<span class="code-keyword">const</span> vwap = trades
  .<span class="code-function">filter</span>(t => t.symbol === <span class="code-string">'AAPL'</span>)
  .<span class="code-function">reduce</span>((acc, t) => {
    acc.sumPQ += t.price * t.qty;
    acc.sumQ += t.qty;
    <span class="code-keyword">return</span> acc;
  }, {sumPQ: <span class="code-number">0</span>, sumQ: <span class="code-number">0</span>});</code></pre>
        </div>
        <div class="comparison-item">
          <h4>Incremental</h4>
          <pre><code><span class="code-comment">// O(Δ) — update state directly</span>
<span class="code-keyword">const</span> state = symbolStates.<span class="code-function">get</span>(<span class="code-string">'AAPL'</span>);
state.sumPQ += newTrade.price * newTrade.qty;
state.sumQ += newTrade.qty;
<span class="code-comment">// VWAP = state.sumPQ / state.sumQ</span></code></pre>
        </div>
      </div>

      <div class="note">
        <p>
          This document covers the core concepts: columnar memory layout, Z-sets for representing changes, 
          operator implementation patterns, and accumulator state management.
        </p>
      </div>
    </section>

    <section id="columnar" class="reveal">
      <h2>Columnar Storage</h2>
      
      <p>
        Row-oriented storage (arrays of objects) scatters related values across memory. 
        Column-oriented storage groups values by field, enabling sequential memory access 
        and better CPU cache utilization.
      </p>

      <h3>Memory Layout Comparison</h3>

      <div class="diagram">
        <div class="diagram-label">Row-oriented</div>
        <div class="memory-layout">
          <div class="memory-row">
            <span class="memory-label">Trade 0:</span>
            <div class="memory-cells">
              <div class="memory-cell sym">AAPL</div>
              <div class="memory-cell price">150.25</div>
              <div class="memory-cell qty">100</div>
              <div class="memory-cell">···</div>
            </div>
          </div>
          <div class="memory-row">
            <span class="memory-label">Trade 1:</span>
            <div class="memory-cells">
              <div class="memory-cell sym">GOOGL</div>
              <div class="memory-cell price">142.80</div>
              <div class="memory-cell qty">50</div>
              <div class="memory-cell">···</div>
            </div>
          </div>
        </div>
        <p style="margin-top: 12px; font-size: 12px; color: var(--text-muted);">
          Summing prices requires jumping between non-contiguous memory locations.
        </p>
      </div>

      <div class="diagram">
        <div class="diagram-label">Column-oriented (TypedArrays)</div>
        <div class="memory-layout">
          <div class="memory-row">
            <span class="memory-label">prices:</span>
            <div class="memory-cells">
              <div class="memory-cell price">150.25</div>
              <div class="memory-cell price">142.80</div>
              <div class="memory-cell price">150.50</div>
              <div class="memory-cell price">···</div>
            </div>
          </div>
          <div class="memory-row">
            <span class="memory-label">quantities:</span>
            <div class="memory-cells">
              <div class="memory-cell qty">100</div>
              <div class="memory-cell qty">50</div>
              <div class="memory-cell qty">200</div>
              <div class="memory-cell qty">···</div>
            </div>
          </div>
        </div>
        <p style="margin-top: 12px; font-size: 12px; color: var(--text-muted);">
          Values are contiguous in memory. CPU prefetching works effectively.
        </p>
      </div>

      <h3>TypedArray Benefits</h3>
      
      <ul>
        <li><strong>Fixed memory layout:</strong> 8 bytes per Float64, no object overhead</li>
        <li><strong>Cache-friendly:</strong> Sequential access patterns</li>
        <li><strong>Zero-copy views:</strong> <code>subarray()</code> creates views without allocation</li>
        <li><strong>JIT optimization:</strong> V8 generates efficient machine code for typed array operations</li>
      </ul>

      <pre><code><span class="code-keyword">const</span> prices = <span class="code-keyword">new</span> <span class="code-type">Float64Array</span>(<span class="code-number">1_000_000</span>);
<span class="code-keyword">const</span> quantities = <span class="code-keyword">new</span> <span class="code-type">Int32Array</span>(<span class="code-number">1_000_000</span>);

<span class="code-comment">// Zero-copy slice for time window</span>
<span class="code-keyword">const</span> recentPrices = prices.<span class="code-function">subarray</span>(startIdx, endIdx);</code></pre>
    </section>

    <section id="zsets" class="reveal">
      <h2>Z-Sets</h2>
      
      <p>
        A Z-set (from DBSP theory) is a multiset where each element has an integer weight. 
        Positive weights represent insertions, negative weights represent deletions. 
        This allows representing changes as data that flows through the same operators as the original data.
      </p>

      <h3>Weight Semantics</h3>
      <table>
        <thead>
          <tr><th>Weight</th><th>Meaning</th><th>Trading Example</th></tr>
        </thead>
        <tbody>
          <tr><td><span class="weight pos">+1</span></td><td>Insert row</td><td>New trade execution</td></tr>
          <tr><td><span class="weight neg">-1</span></td><td>Delete row</td><td>Trade bust/cancellation</td></tr>
          <tr><td><code>0</code></td><td>No effect</td><td>Filtered out</td></tr>
        </tbody>
      </table>

      <h3>Example: Trade Corrections</h3>
      <table>
        <thead>
          <tr><th>Weight</th><th>Symbol</th><th>Price</th><th>Qty</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr>
            <td><span class="weight pos">+1</span></td>
            <td><span class="ticker">AAPL</span></td>
            <td>150.25</td><td>100</td>
            <td style="color: var(--text-muted);">Initial fill</td>
          </tr>
          <tr>
            <td><span class="weight neg">-1</span></td>
            <td><span class="ticker">AAPL</span></td>
            <td>150.25</td><td>100</td>
            <td style="color: var(--text-muted);">Bust the fill</td>
          </tr>
          <tr>
            <td><span class="weight pos">+1</span></td>
            <td><span class="ticker">AAPL</span></td>
            <td>150.50</td><td>100</td>
            <td style="color: var(--text-muted);">Corrected price</td>
          </tr>
        </tbody>
      </table>

      <p>
        When these rows flow through an aggregation, the weight is multiplied into the computation. 
        The bust (<code>-1</code>) automatically subtracts the incorrect values from running totals.
      </p>

      <pre><code><span class="code-comment">// VWAP with weights</span>
<span class="code-keyword">for</span> (<span class="code-keyword">const</span> trade <span class="code-keyword">of</span> delta) {
  state.sumPQ += trade.price * trade.qty * trade.weight;
  state.sumQ += trade.qty * trade.weight;
}
<span class="code-comment">// Deletions subtract automatically</span></code></pre>
    </section>

    <section id="operators" class="reveal">
      <h2>Operators</h2>
      
      <p>
        Operators transform Z-sets. They divide into two categories based on whether 
        they maintain state between invocations.
      </p>

      <h3>Stateless Operators</h3>
      <p>
        Process each row independently. Output depends only on the current input row.
      </p>
      <ul>
        <li><strong>Filter:</strong> Sets weight to 0 for non-matching rows</li>
        <li><strong>Map:</strong> Transforms values, preserves weights</li>
        <li><strong>Select:</strong> Projects columns</li>
      </ul>

      <pre><code><span class="code-keyword">function</span> <span class="code-function">filter</span>(input: ZSet, predicate: (row) => <span class="code-type">boolean</span>): ZSet {
  <span class="code-keyword">const</span> newWeights = <span class="code-keyword">new</span> <span class="code-type">Int32Array</span>(input.length);
  <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < input.length; i++) {
    newWeights[i] = <span class="code-function">predicate</span>(input, i) ? input.weights[i] : <span class="code-number">0</span>;
  }
  <span class="code-keyword">return</span> input.<span class="code-function">withWeights</span>(newWeights);
}</code></pre>

      <h3>Stateful Operators</h3>
      <p>
        Maintain state across invocations. Required for aggregations, joins, and windowing.
      </p>

      <div class="diagram">
        <div class="diagram-label">Pipeline example</div>
        <div class="pipeline">
          <div class="pipeline-node">Trades<small>source</small></div>
          <span class="pipeline-arrow">→</span>
          <div class="pipeline-node">Filter<small>symbol='AAPL'</small></div>
          <span class="pipeline-arrow">→</span>
          <div class="pipeline-node">GroupBy<small>VWAP by side</small></div>
          <span class="pipeline-arrow">→</span>
          <div class="pipeline-node">Output<small>deltas</small></div>
        </div>
      </div>

      <pre><code><span class="code-keyword">class</span> <span class="code-type">GroupByOperator</span> {
  <span class="code-keyword">private</span> groups = <span class="code-keyword">new</span> <span class="code-type">Map</span>&lt;<span class="code-type">string</span>, AccumulatorState&gt;();
  
  <span class="code-function">step</span>(delta: ZSet): ZSet {
    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < delta.length; i++) {
      <span class="code-keyword">const</span> w = delta.weights[i];
      <span class="code-keyword">if</span> (w === <span class="code-number">0</span>) <span class="code-keyword">continue</span>;
      
      <span class="code-keyword">const</span> key = <span class="code-keyword">this</span>.<span class="code-function">computeKey</span>(delta, i);
      <span class="code-keyword">const</span> acc = <span class="code-keyword">this</span>.groups.<span class="code-function">get</span>(key) ?? <span class="code-keyword">this</span>.<span class="code-function">createAccumulator</span>();
      acc.<span class="code-function">add</span>(delta, i, w);
      <span class="code-keyword">this</span>.groups.<span class="code-function">set</span>(key, acc);
    }
    <span class="code-keyword">return</span> <span class="code-keyword">this</span>.<span class="code-function">emitChanges</span>();
  }
}</code></pre>
    </section>

    <section id="accumulators" class="reveal">
      <h2>Accumulators</h2>
      
      <p>
        Accumulators maintain the state needed for incremental aggregation. 
        Different aggregations have different state requirements.
      </p>

      <h3>State Complexity by Aggregation</h3>
      <table>
        <thead>
          <tr><th>Aggregation</th><th>State</th><th>Update</th><th>Notes</th></tr>
        </thead>
        <tbody>
          <tr><td>sum</td><td class="good">O(1)</td><td class="good">O(1)</td><td>Single value</td></tr>
          <tr><td>count</td><td class="good">O(1)</td><td class="good">O(1)</td><td>Single value</td></tr>
          <tr><td>mean</td><td class="good">O(1)</td><td class="good">O(1)</td><td>sum + count</td></tr>
          <tr><td>VWAP</td><td class="good">O(1)</td><td class="good">O(1)</td><td>sumPQ + sumQ</td></tr>
          <tr><td>min/max</td><td class="warn">O(k)</td><td class="good">O(1)</td><td>Track all values with counts</td></tr>
          <tr><td>distinct</td><td class="warn">O(k)</td><td class="good">O(1)</td><td>Set of seen values</td></tr>
        </tbody>
      </table>

      <h3>Interactive Example: Position Tracking</h3>
      <div class="demo">
        <div class="demo-header">
          <span class="demo-title">Position accumulator (AAPL)</span>
          <div class="demo-controls">
            <button class="demo-btn" onclick="reset()">Reset</button>
            <button class="demo-btn buy" onclick="buy()">Buy 100</button>
            <button class="demo-btn sell" onclick="sell()">Sell 50</button>
            <button class="demo-btn" onclick="bust()">Bust</button>
          </div>
        </div>
        <div class="demo-body">
          <div class="state-display">
            <div class="state-item">
              <div class="label">Position</div>
              <div class="value" id="pos">0</div>
            </div>
            <div class="state-item">
              <div class="label">Avg Cost</div>
              <div class="value" id="cost">$0.00</div>
            </div>
          </div>
          <div class="log" id="log">
            <div class="log-entry"><span class="action">init</span> position=<span class="result">0</span></div>
          </div>
        </div>
      </div>

      <h3>Min/Max Complexity</h3>
      <p>
        Unlike sum-based aggregations, min and max cannot be computed incrementally from a single 
        stored value. When the current minimum is deleted, the accumulator must find the new minimum 
        from remaining values. This requires storing all distinct values and their counts.
      </p>

      <pre><code><span class="code-keyword">class</span> <span class="code-type">MinAccumulator</span> {
  <span class="code-keyword">private</span> values = <span class="code-keyword">new</span> <span class="code-type">Map</span>&lt;<span class="code-type">number</span>, <span class="code-type">number</span>&gt;(); <span class="code-comment">// value → count</span>
  
  <span class="code-function">add</span>(value: <span class="code-type">number</span>, weight: <span class="code-type">number</span>) {
    <span class="code-keyword">const</span> count = (<span class="code-keyword">this</span>.values.<span class="code-function">get</span>(value) ?? <span class="code-number">0</span>) + weight;
    <span class="code-keyword">if</span> (count <= <span class="code-number">0</span>) <span class="code-keyword">this</span>.values.<span class="code-function">delete</span>(value);
    <span class="code-keyword">else</span> <span class="code-keyword">this</span>.values.<span class="code-function">set</span>(value, count);
  }
  
  <span class="code-function">get</span>(): <span class="code-type">number</span> | <span class="code-type">null</span> {
    <span class="code-keyword">if</span> (<span class="code-keyword">this</span>.values.size === <span class="code-number">0</span>) <span class="code-keyword">return</span> <span class="code-keyword">null</span>;
    <span class="code-keyword">return</span> <span class="code-type">Math</span>.<span class="code-function">min</span>(...<span class="code-keyword">this</span>.values.<span class="code-function">keys</span>());
  }
}</code></pre>
    </section>

    <section id="benchmarks" class="reveal">
      <h2>Benchmarks</h2>
      
      <p>
        Measurements from Node.js v22, 100,000 rows, filter→map→groupBy pipeline.
      </p>

      <h3>Implementation Comparison</h3>
      <div class="diagram">
        <div class="perf-bars">
          <div class="perf-bar-group">
            <div class="perf-bar a" style="height: 100px;"><span class="val">305 ms</span></div>
            <div class="perf-label">Row-based</div>
          </div>
          <div class="perf-bar-group">
            <div class="perf-bar b" style="height: 28px;"><span class="val">85 ms</span></div>
            <div class="perf-label">Arrow</div>
          </div>
          <div class="perf-bar-group">
            <div class="perf-bar c" style="height: 4px;"><span class="val">12 ms</span></div>
            <div class="perf-label">JS Columnar</div>
          </div>
          <div class="perf-bar-group">
            <div class="perf-bar d" style="height: 1px;"><span class="val">3.8 ms</span></div>
            <div class="perf-label">TypedArray</div>
          </div>
        </div>
      </div>

      <h3>Incremental vs Full Recomputation</h3>
      <table>
        <thead>
          <tr><th>Delta Size</th><th>Incremental</th><th>Full</th><th>Speedup</th></tr>
        </thead>
        <tbody>
          <tr><td>0.1% (100 rows)</td><td>0.012 ms</td><td>1.91 ms</td><td class="good">153×</td></tr>
          <tr><td>1% (1,000 rows)</td><td>0.022 ms</td><td>1.71 ms</td><td class="good">78×</td></tr>
          <tr><td>10% (10,000 rows)</td><td>0.248 ms</td><td>1.84 ms</td><td class="warn">7.4×</td></tr>
        </tbody>
      </table>

      <h3>Combined Effect</h3>
      <p>
        At 100K rows with 10% delta:
      </p>
      <ul>
        <li>Row-based full: 39.8 ms</li>
        <li>TypedArray incremental: 0.25 ms</li>
        <li>Combined speedup: ~160×</li>
      </ul>

      <div class="note">
        <p>
          The benefit scales with data size and inversely with delta size. 
          For streaming trade data with small deltas, incremental processing 
          maintains sub-millisecond update latency regardless of total data volume.
        </p>
      </div>
    </section>
  </main>

  <footer>
    <p>Based on PandaJS architecture and research by Hassan Al-Ubeidi (2026).</p>
    <p>Theory: <a href="https://www.vldb.org/pvldb/vol16/p1601-budiu.pdf">DBSP: Automatic Incremental View Maintenance</a> (Budiu et al., 2023)</p>
  </footer>

  <script>
    // Nav
    const sections = document.querySelectorAll('section');
    const navLinks = document.querySelectorAll('nav a');
    window.addEventListener('scroll', () => {
      let current = '';
      sections.forEach(s => { if (scrollY >= s.offsetTop - 100) current = s.id; });
      navLinks.forEach(a => {
        a.classList.toggle('active', a.getAttribute('href') === `#${current}`);
      });
    });

    // Reveal
    const reveals = document.querySelectorAll('.reveal');
    const obs = new IntersectionObserver(entries => {
      entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
    }, { threshold: 0.1 });
    reveals.forEach(el => obs.observe(el));

    // Demo
    let pos = 0, cost = 0, last = null;
    const posEl = document.getElementById('pos');
    const costEl = document.getElementById('cost');
    const logEl = document.getElementById('log');

    function update() {
      posEl.textContent = pos;
      posEl.className = 'value' + (pos < 0 ? ' negative' : '');
      costEl.textContent = '$' + (pos ? Math.abs(cost/pos).toFixed(2) : '0.00');
    }

    function log(action, qty, price, w, p) {
      const e = document.createElement('div');
      e.className = 'log-entry';
      const pc = p < 0 ? 'neg' : '';
      e.innerHTML = `<span class="action">${action}</span> qty=<span class="num">${qty}</span> @<span class="num">$${price.toFixed(2)}</span> w=${w>0?'+1':'-1'} → <span class="result ${pc}">${p}</span>`;
      logEl.appendChild(e);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function buy() {
      const q = 100, p = 150 + Math.random()*2;
      pos += q; cost += q*p;
      last = {t:'buy',q,p};
      update(); log('buy',q,p,1,pos);
    }

    function sell() {
      const q = 50, p = 150 + Math.random()*2;
      pos -= q; cost -= q*p;
      last = {t:'sell',q,p};
      update(); log('sell',q,p,1,pos);
    }

    function bust() {
      if (!last) return;
      if (last.t === 'buy') { pos -= last.q; cost -= last.q*last.p; log('bust buy',last.q,last.p,-1,pos); }
      else { pos += last.q; cost += last.q*last.p; log('bust sell',last.q,last.p,-1,pos); }
      last = null;
      update();
    }

    function reset() {
      pos = 0; cost = 0; last = null;
      update();
      logEl.innerHTML = '<div class="log-entry"><span class="action">init</span> position=<span class="result">0</span></div>';
    }
  </script>
</body>
</html>
